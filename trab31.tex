% Terceira lista de exercícios de Métodos Numéricos
% Preparado para MiKTeX 2.9. Gerar arquivo PDF com pdflatex.
\documentclass[12pt,fleqn]{amsart}
%\begin{}Preãmbulo
\usepackage{enumitem}
\usepackage{xstring}
\usepackage[pdftex]{graphicx}
\usepackage[a4paper]{geometry}
\usepackage[english,brazilian]{babel}
\usepackage[ansinew]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{comment}
\usepackage{bigfoot}
% Fontes
\usepackage{textgreek}
\usepackage{yfonts}
\usepackage{microtype}
\usepackage{calligra}
\usepackage{lmodern}
\usepackage{bookman}
\usepackage[scaled]{helvet}
%\usepackage{courier}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage[hyphens]{url}
\usepackage{hyperref}
%\usepackage{hyphenat}
%\hyphenation{mate-mática recu-perar}
\usepackage{fmtcount}
\usepackage[nonumberlist,acronym,sort=def]{glossaries}
% Formatação
\usepackage{sidecap}
\usepackage{fixltx2e}
\usepackage{float}
\usepackage{listings}
\usepackage[numbered,framed]{matlab-prettifier}
\usepackage{multirow}
\usepackage{pdflscape}
\usepackage{footnote}
\usepackage{tablefootnote}
% Símbolos matemáticos
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{wasysym}
\usepackage{mathtools}
\usepackage{bbm}
\usepackage{mbboard}
\usepackage{bm}
% Desenhos
\usepackage{tikz}

\usetikzlibrary{shapes,arrows}

%\end{}

\title{Métodos Numéricos - Lista de Exercícios III}
\date{}
\author{Sérgio Cordeiro}
%\end{}

%\begin{}Comandos
\renewcommand*\contentsname{Sumário}

\newenvironment{inthisrev}{
	\color{blue}
	}{
	\color{black}
	}

\newenvironment{myquote}{
	\begin{quote}
	\fontfamily{lmr} \selectfont
	{\huge ``}}{{\huge ''}
	\end{quote}
	}

\newenvironment{pergunta}{
	\par
	\trivlist
	\fontfamily{phv}
	\selectfont
	\item\arabic{prob_num}. 
	}{
	\endtrivlist
	}

\newenvironment{resposta}{
	\trivlist
    \vspace{3pt}
	\fontfamily{pbk}
	\selectfont
	\item
	}{
	\vspace{3pt}
	\noindent\makebox[\linewidth]{\rule{\paperwidth}{1pt}}
	\endtrivlist
	\stepcounter{prob_num}
	}

\newenvironment{lista}{
	\vspace{-5mm}
	\begin{itemize}}{
	\end{itemize}	
	\vspace{-5mm}}

\newenvironment{listaf}{
	\vspace{-5mm}
	\begin{itemize}}{
	\end{itemize}}

\newenvironment{listae}[1][]{
  \IfStrEqCase{#1}{
    {1}{\setenumerate[0]{label=\arabic*.}}
    {2}{\setenumerate[0]{label=\alph*)}}
    {3}{\setenumerate[0]{label=\roman*.}}
	{}{\setenumerate[0]{label=\arabic*)}}}
	\vspace{-5mm}
	\begin{enumerate}}{
	\end{enumerate}	
	\vspace{-5mm}}

\newenvironment{listaef}[1][]{
  \IfStrEqCase{#1}{
    {1}{\setenumerate[0]{label=\arabic*.}}
    {2}{\setenumerate[0]{label=\alph*)}}
    {3}{\setenumerate[0]{label=\roman*.}}
	{}{\setenumerate[0]{label=\arabic*)}}}
	\vspace{-5mm}
	\begin{enumerate}}{
	\end{enumerate}}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{it}

\newcommand{\matriz}[1]{\mathbf{#1}}

\newcommand{\dt}[1]{\frac{d {#1}}{dt}}					% derivada temporal
\newcommand{\ddt}[1]{\frac{d^2 {#1}}{dt^2}}				% derivada segunda temporal
\newcommand{\dddt}[1]{\frac{d^3 {#1}}{dt^3}}			% derivada terceira temporal
\newcommand{\dtau}[1]{\frac{d {#1}}{d \tau}}			% derivada temporal
\newcommand{\ddtau}[1]{\frac{d^2 {#1}}{d \tau^2}}		% derivada segunda temporal

\newcommand{\newbibit}[6]{\bibitem[#1]{#2}#3, {\bf #4}. Disponível em \url{#5}, acesso em #6.}
\newcommand{\newbibpp}[5]{\bibitem[#1]{#2}#3, {\bf #4}, \emph{in} #5.}
\newcommand{\newbibbk}[5]{\bibitem[#1]{#2}#3, {\bf #4}, #5.}
\newcommand{\newbibip}[6]{\bibitem[#1]{#2}#3, {\bf #4}, \emph{in} #5, disponível em \url{#6}.}
\newcommand{\newbiboc}[4]{\bibitem[#1]{#2}#3, \textit{op. cit.}, #4.}
\newcommand{\newbibsi}[7]{\bibitem[#1]{#2}#3, {\bf #4}: {#5}. Disponível em \url{#6}, acesso em #7.}

\newenvironment{iquote}{\begin{quote}\itshape}{\end{quote}}

\BeforeBeginEnvironment{figure}{\vskip-1ex}
\AfterEndEnvironment{figure}{\vskip-4ex}

% Linhas divisórias
\newcommand{\hhhlin}{\noindent\hfil\rule{0.25\textwidth}{.2pt}\hfil\newline}
\newcommand{\hhlin}{\noindent\hfil\rule{0.5\textwidth}{.4pt}\hfil\newline}
\newcommand{\hlin}{\noindent\hfil\rule{\textwidth}{.8pt}\hfil\newline}

% Listagens
\newcommand{\listingsO}{\lstset{language=Octave,literate={^}{\textasciicircum}1,frame=single,style=Matlab-editor,basicstyle={\tiny},breaklines=true,numbers=left,numberstyle={\color{red}},numbersep=9pt,showstringspaces=false,keepspaces=false,tabsize=2}}
\newcommand{\listingsC}{\lstset{language=C,frame=single,basicstyle={\tiny},breaklines=true,numbers=left,numberstyle={\color{red}},numbersep=9pt,showstringspaces=false,keepspaces=false,tabsize=2}}
\newcommand{\listingsG}{\lstset{language=Ada,frame=none,basicstyle={\ttfamily\bfseries},numbers=none,tabsize=2,mathescape}}

%\end{}

%\begin{}Perguntas

\newcommand{\perguntaa}{Sobre SVD: apresente modelagem matemática para calculo; apresente aplicações práticas; escolha uma aplicação associada à compressão de matrizes e faça a decomposição, a compressão e a analise o número de condicionamento antes e depois da compressão. Comente e analise todos os resultados.}
\newcommand{\perguntab}{Simule (utilizando qualquer software) o circuito da figura 1 e obtenha a tabela de valores (t (seg) e I (A)). Resolva analiticamente o circuito. Faça o ajuste da função utilizando regressão (avalie a que melhor se adeque a esse problema). Plote em um gráfico os valores simulados, calculados (solução analítica) e os valores obtidos a partir da regressão. Escolha os valores para os elementos de forma que a resposta seja oscilatória. Comente os resultados.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{trab31figb1.jpg} \\
\end{figure}%
}
\newcommand{\perguntac}{Para os Tópicos: Interpolação de Hermite, Interpolação com \textit{Spline} Cúbico e Extrapolação faça:
\begin{lista}
	\item Descrição de um problema real;
	\item Modelagem matemática e numérica (código em anexo);
	\item Resultados e conclusões
\end{lista}
}
\newcommand{\perguntad}{O gráfico a seguir apresenta as variações do PIB e PIB/percapita.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{trab31figd1.jpg} \\
\end{figure}%
Para esses dados (PIB e PIB per capita) faça:
\begin{listae}[1]
	\item Encontre o polinômio interpolador que melhor represente essa função (PI de maior grau possível) (Use interpolação);
	\item Plote o diagrama de dispersão e o PI encontrado;
	\item Comente todos os resultados
\end{listae}
}
%\end{}

%\begin{}Glossário
\renewcommand{\glossarymark}[1]{}
\glsnogroupskiptrue
\makeglossaries
\makeindex
\setglossarystyle{list}

\newglossaryentry{DecQR}{
  name={Decomposição QR},
  text={decomposição QR},  
  description={É decomposição de uma matrz em um produto de duas matrizes, $ \matriz{Q} \text{ e } \matriz{R} \text{, em que } \matriz{Q} $ é uma \gls{MatOrt} e $ \matriz{R} $ é uma matriz triangular superior}
  }%
\newglossaryentry{DIIS}{
  name={\textit{Direct Inversion in the Iterative Subspace}},
  text={DIIS},
  description={Também conhecida como \textbf{Mistura de Pulay} (\textit{Pulay Mixing}), é uma técnica iterativa de extrapolação em que o novo valor é obtido como combinação dos vetores de erro referentes às iterações prévias, de forma a minimizar o vetor de coeficientes}
  }%
\newglossaryentry{MatHess}{
  name={Matriz de Hessenberg},
  text={matriz de Hessenberg},  
  description={É uma matriz quase triangular, ou seja, uma matriz cujos elementos são nulos a não ser acima da diagonal imediatamente abaixo da principal (matriz de Hessenberg superior) ou abaixo da diagonal imediatamente acima da principal (matriz de Hessenberg inferior)}
  }%
\newglossaryentry{MatOrt}{
  name={Matriz ortogonal},
  text={matriz ortogonal},  
  description={É uma matriz quadrada cujas linhas e colunas são todas vetores ortonormais}
  }%
\newglossaryentry{MatSemSep}{
  name={Matriz semi-separável},
  text={matriz semi-separável},  
  description={É uma matriz cujo rank, considerada apenas a parte inferior até a diagonal acima da principal, é igual ou menor que 1}
  }%
\newglossaryentry{MINRES}{
  name={\textit{Minimal Residual}},
  text={MINRES},  
  description={Método iterativo para solução de sistemas lineares simétricos e esparsos que tenta minimizar alguma norma do resíduo}
  }%
\newglossaryentry{Ref}{
  name={Refletor},
  text={refletor},
  plural={refletores},
  description={É uma matriz cujo determinate é igual a -1}
  }%
\newglossaryentry{RefHou}{
  name={Refletor de Householder},
  text={refletor de Householder},  
  plural={refletores de Householder},  
  description={É um \gls{Ref} que, aplicado a uma outra matriz, produz uma reflexão da mesma em torno da origem. É usado no algoritmo de \gls{DecQR}}
  }%
\newacronym[see={[Glossary:]{MINRES}}]{MINRESa}{MINRES}{\glslink{MINRES}{\textit{Minimal Residual}}}%
\newacronym[see={[Glossary:]{DIIS}}]{DIISa}{DIIS}{\glslink{DIIS}{\textit{Direct Inversion in the Iterative Subspace}}}%

%\end{}

\begin{document}

\setlength{\parskip}{1em}
\setlength{\jot}{10pt}
\setlength{\parindent}{0pt}

\maketitle

\tableofcontents

\newcounter{prob_num}
\setcounter{prob_num}{1}

\clearpage

\section{Problemas}
\begin{pergunta}
\perguntaa{}
\end{pergunta}
\begin{resposta}
Os \textbf{valores singulares} são uma generalização dos autovalores, pois aplicam-se não apenas a matrizes quadradas. A decomposição SVD de uma matriz $ \matriz{A} $ consiste na sua substituição pelo produto de três outras matrizes: $ \matriz{A} = \matriz{U} \matriz{S} \matriz{V}^{(T)} \text{, onde } \matriz{U} \text{ e } \matriz{V} $ são unitárias e $ \matriz{S} $ é diagonal. Pode-se demonstrar que toda matriz pode ser decomposta dessa forma, e que a decomposição é única, a menos da ordem das colunas das matrizes. \\
A generalização dos autovetores são os \textbf{vetores singulares}. As colunas de $ \matriz{U} $ são chamadas de vetores singulares à esquerda, e as de $ \matriz{U} $, de vetores singulares à direita. \\
A aplicação imediata da decomposição SVD é a solução mais fácil de um sistema linear, pois $ \matriz{U} \text{ e } \matriz{V} $ são matrizes unitárias, por isso suas transpostas são as inversas; $ \matriz{S} $, por sua vez, é diagonal, e encontrar sua inversa é trivial. Portanto:
\begin{align*}
	\matriz{A} \matriz{x} = \matriz{b} \implies \qquad \matriz{x} & = \matriz{A}^{-1} \matriz{b} \\
	& = \left( \frac{}{} \matriz{U} \matriz{S} \matriz{V}^{(T)} \right)^{-1} \matriz{b} \\
	& = \matriz{V} \matriz{S}^{-1} \matriz{U}^{(T)} \matriz{b} \\
\end{align*}
Uma segunda aplicação é a compressão da matriz, que pode ser expressa pelo produto $ \matriz{\hat{U}} \matriz{\hat{S}} \matriz{\hat{V}}^{(T)} $, com as matrizes $ \matriz{\hat{U}} \text{, } \matriz{\hat{S}} \text{ e } \matriz{\hat{V}}^{(T)} $ derivadas das originais por eliminação de colunas menos significativas, correspondentes a valores singulares de menor valor absoluto. \\
Uma terceira aplicação é a diminuição do número de condicionamento da matriz, através da eliminação dos valores singulares com menor valor absoluto. A melhoria no condicionamento torna a matriz mais adequada ao trataemnto por métodos iterativos. \\
Finalmente, uma quarta aplicação é no cálculo da \textbf{pseudoinversa} de uma matriz, que é definida como:
\begin{align*}
	\matriz{A}^\dagger & = \matriz{A}A^T(\matriz{A}\matriz{A}^T)^{-1} \text{ ou } \\
	\matriz{A}^\dagger & = (\matriz{A}A^T \matriz{A})^{-1} \matriz{A}^T
\end{align*}
dependendo de qual produto, $ \matriz{A}\matriz{A}^T \text{ ou } \matriz{A}A^T \matriz{A} $, for invertível. A pseudoinversa é dada por:
\begin{align*}
	\matriz{A}^\dagger = \matriz{V} \matriz{S}^\dagger \matriz{U}^T
\end{align*}
cujo cálculo é fácil, uma vez que $ \matriz{S} $ é diagnonal \cite{FASSHAUER 2006,PRESS 1992 1,VETTERLI 2014}. \\
\hlin
A compressão de matrizes por meio da decomposição SVD usa a técnica conhecida como \textit{low-rank approximation}: após encontrarem-se os $ n $ autovalores, selecionam-se os $ m $ maiores; todas linhas de $ \matriz{U} \text{ e } \matriz{V} $ são mantidas, mas apenas as $ m $ colunas que correspondem aos maiores autovalores dessas matrizes; quanto a $ \matriz{S} $, são selecionadas tanto as linhas quanto as colunas que correspondem aos autovalores mais importantes. O resultado é uma matriz $ \matriz{C} $ que tem o mesmo tamanho da matriz original, mas apenas $ m $ autovalores. \\
A manutenção dos maiores autovalores faz com que a maior parte da variãncia original seja preservada, e com ela, a informação relevante. O número de condição, por sua vez, é bastante melhorado. \\ 
\hlin
A aplicação escolhida foi a compressão de imagens em preto e branco, com e sem introdução de ruído. As imagens originais foram obtidas no banco de dados do Departamento de Engenharia Elétrica e de Computação do Instituto Politécnico da Universidade de Nova York. \\
O programa \textbf{\texttt{exercmat.c}}, em anexo, escrito em C, lê uma matriz em disco e comprime-a pelo método de decomposição SVD, calculando o número de condicionamento antes e depois da compressão. Basta digitar:
\listingsG
\begin{lstlisting}[language=Ada]
	exercmat 20 $ \textit{n} $
\end{lstlisting}
onde $ n $ é o tamanho da matriz (n x n). Ele também calcula o número de operações em ponto flutuante necessário para cada etapa. O próprio programa tenta descobrir qual é a maior taxa de compressão possível sem que resulte perda expressiva de dados. \\
O algoritmo é totalmente genérico, e pode ser aplicado diretamente a uma matriz que representa uma imagem. Para este exercício, experimentou-se com alguns valores diferentes para a taxa de compressão. \\
O algoritmo usa o método de Jacobi para encontrar os autovalores e autovetores da matriz $ \matriz{A}^{(T)} \matriz{A} $, o que não é uma solução ótima. \\
Os resultados obtidos são mostrados e tabelados a seguir. Foi usada apenas precisão simples, de forma a favorecer a ocorrência de erros de arredondamento. \\
\\[\baselineskip]
\begin{minipage*}{\textwidth}
\centering
    \begin{tabular}{|c|c|c|c|c|c|}
		\hline
        \multicolumn{2}{|c|}{\textbf{n}} & \textbf{nome} & \multicolumn{2}{|c|}{\textbf{Número de condição}} & \textbf{iterações} \\
		\textbf{antes} & \textbf{depois} & & \textbf{antes} & \textbf{depois} & \\
		\hline
		\multirow{4}{*}{$ 512 $} & $ 347 $ & \multirow{4}{*}{Lena} & \multirow{4}{*}{$ 38.146271 $} & $ 1.860093 $ & \multirow{4}{*}{$ 406 $} \\
		& $ 240 $ & & & $ 1.495879 $ & \\
		& $ 149 $ & & & $ 1.273939 $ & \\
		& $ 71 $ & & & $ 1.142361 $ & \\
		\hline
		\multirow{4}{*}{$ 512 $} & $ 336 $ & \multirow{4}{*}{Bárbara} & \multirow{4}{*}{$ 23.812378 $} & $ 1.879261 $ & \multirow{4}{*}{$ 348 $} \\
		& $ 232 $ & & & $ 1.471599 $ & \\
		& $ 145 $ & & & $ 1.275514 $ & \\
		& $ 68 $ & & & $ 1.138802 $ & \\
		\hline
    \end{tabular}
\end{minipage*}
\\[\baselineskip]
\begin{minipage*}{\textwidth}
\centering
    \begin{tabular}{|c|c|c|c|c|}
		\hline
        \multicolumn{2}{|c|}{\textbf{n}} & \textbf{nome} & \multicolumn{2}{|c|}{\textbf{custo} \footnote{Número de operações de ponto flutuante necessárias.}} \\
		\textbf{antes} & \textbf{depois} & & \textbf{decomposição} & \textbf{compressão} \\
		\hline
		\multirow{4}{*}{$ 512 $} & $ 347 $ & \multirow{4}{*}{Lena} & \multirow{4}{*}{$ 35047344300288 $} & $ 304347657 $ \\
		& $ 240 $ & & & $ 184041993 $ \\
		& $ 149 $ & & & $ 100176393 $ \\
		& $ 71 $ & & & $ 41789961 $ \\
		\hline
		\multirow{4}{*}{$ 512 $} & $ 336 $ & \multirow{4}{*}{Bárbara} & \multirow{4}{*}{$ 35047344300288 $} & $ 290898441 $ \\
		& $ 232 $ & & & $ 175989257 $ \\
		& $ 145 $ & & & $ 96879113 $ \\
		& $ 68 $ & & & $ 39793161 $ \\
		\hline
    \end{tabular}
\end{minipage*}
\\[2\baselineskip]
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{lena_gray.jpg} \\
	Imagem original: Lena com 512 valores singulares
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{barbara_gray.jpg} \\
	Imagem original: Bárbara com 512 valores singulares
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{lena_347.jpg} \\
	Imagem comprimida: Lena com 347 valores singulares
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{barbara_336.jpg} \\
	Imagem comprimida: Bárbara com 336 valores singulares
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{lena_240.jpg} \\
	Imagem comprimida: Lena com 240 valores singulares
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{barbara_232.jpg} \\
	Imagem comprimida: Bárbara com 232 valores singulares
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{lena_149.jpg} \\
	Imagem comprimida: Lena com 149 valores singulares
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{barbara_145.jpg} \\
	Imagem comprimida: Bárbara com 145 valores singulares
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{lena_71.jpg} \\
	Imagem comprimida: Lena com 71 valores singulares
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{barbara_68.jpg} \\
	Imagem comprimida: Bárbara com 68 valores singulares
\end{figure}%
Para a pronunciada compressão obtida, as imagens mostram que a informação importante foi preservada. \\
\end{resposta}

\clearpage

\begin{pergunta}
\perguntab{}
\end{pergunta}
\begin{resposta}
A função de transferência $ \mathpzc{G}(s) = \frac{\mathpzc{I}(s)}{\mathpzc{V}(s)} $ correspondente é:
\begin{align*}
	\mathpzc{G}(s) &= \dfrac{1}{R + Ls + \frac{1}{Cs}} \\
	& = \frac{Cs}{LCs^2 + RCs + 1}
	& = \frac{Cs}{As^2 + Bs + 1} \qquad \Aboxed{LC = A \text{,} RC = B}
\end{align*}
O diagrama de simulação correspondente é o seguinte:
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{trab31b1.jpg} \\
\end{figure}%
e a saída simulada é a seguinte, para $ A = 0.001 \text{, } B = 0.003 \text{ e } C = 0.1 $:
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{trab31b2.jpg} \\
\end{figure}%
Evidentemente, $ C = 0.1 \; F \text{, } L = \frac{A}{C} = \frac{0.001}{0.1} = 0.01 \; H \text{ e } R = \frac{B}{C} = \frac{0.003}{0.1} = 0.03 \; \Omega $, que não são valores muito realísticos, mas servem como ilustração. \\
As raízes da equação característica são:
\begin{align*}
	A \lambda^2 + B \lambda  + 1 = 0 \implies \qquad \lambda & = \frac{-B \pm \sqrt{B^2 - 4A}}{2A} \\
	& = \frac{-0.003 \pm \sqrt{0.003^2 - 4 \times 0.001}}{2 \times 0.001} \\
	& = \frac{-0.003 \pm \jmath 0.0632}{0.002} \\
	& = -1.5 \pm \jmath 31.6
\end{align*}
Assim, a forma da resposta será $ y = D e^{-1.5t} \sin (31.6 t + E) $. Como $ y(0) = 0 \text{, então } E = 0 $. 
O programa \textbf{\texttt{exercmat.c}}, em anexo, escrito em C, lê uma matriz em disco e ajusta a ela um polinômio por regressão polinomial, usando o método dos mínimos quadrados. Basta digitar:
\listingsG
\begin{lstlisting}[language=Ada]
	exercmat 32 $ \textit{n} $
\end{lstlisting}
onde $ n $ é o tamanho do problema. Ele também calcula a qualidade da aproximação e o número de operações em ponto flutuante necessário para cada etapa. \\
Para ajustar um polinômio aos pontos disponíveis, selecionaram-se as amostras correspondentes aos 100 valores anteriores a $ x = 1 $ e tentaram-se graus crescentes para o polinômio. Os resultados obtidos são mostrados na tabela abaixo e ilustrados pelos gráficos que se seguem. Os gráficos foram plotados em baixa definição, usando-se apenas 10 pontos, de forma a não incorrer em custo de processamento alto.
\\[\baselineskip]
\begin{minipage*}{\textwidth}
\centering
    \begin{tabular}{|c|c|c|c|c|}
		\hline
        \textbf{grau} & \textbf{coeficiente de} & \textbf{variãncia} & \multicolumn{2}{|c|}{\textbf{custo} \footnote{Número de operações de ponto flutuante necessárias.}} \\
        & \textbf{determinação} & \textbf{residual} & \textbf{ajuste} & \textbf{avaliação} \\	\hline
		$ 1 $ & $ 0.006412 $ & $ 0.065045 $ & $ 739 $ & $ 1670 $ \\
		$ 2 $ & $ 0.282749 $ & $ 0.047438 $ & $ 1578 $ & $ 2709 $ \\
		$ 3 $ & $ 0.991840 $ & $ 0.000545 $ & $ 2632 $ & $ 3963 $ \\
		$ 4 $ & $ 0.983997 $ & $ 0.001081 $ & $ 3905 $ & $ 5436 $ \\
		$ 5 $ & $ 0.989866 $ & $ 0.000692 $ & $ 5401 $ & $ 7132 $ \\
		\hline
    \end{tabular}
\end{minipage*}
\\[\baselineskip]
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{trab31figb2.jpg} \\
	$ \alpha_1 = 0.680600 \text{, } \alpha_0 = -1.105716 $
\end{figure}%
\clearpage
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{trab31figb3.jpg} \\
	$ \alpha_2 = 560.891174 \text{, } \alpha_1 = -1060.951416 \text{, } \alpha_0 = 500.748230 $
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{trab31figb4.jpg} \\
	$ \alpha_3 = 156.376862 \text{, } \alpha_2 = -144.615555 \text{, } $ \\
	$ \alpha_1 = -145.984055 \text{, } \alpha_0 = 134.404083 $
\end{figure}%
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{trab31figb5.jpg} \\
	$ \alpha_4 = 196.042389 \text{, } \alpha_3 = -263.384857 \text{, } \alpha_2 = 15.143293 \text{, } $ \\
	$ \alpha_1 = 14.279124  \text{, } \alpha_0 = 38.165676 $
\end{figure}
\vskip 2ex
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{trab31figb6.jpg} \\
	$ \alpha_5 = 23.204826 \text{, } \alpha_4 = 13.646919 \text{, } \alpha_3 = 43.347961 \text{, } $ \\
	$ \alpha_2 = -84.813011 \text{, } \alpha_1 = -95.061539 \text{, } \alpha_0 = 99.884033 $
\end{figure}%
As curvas mostram que não há melhoria apreciável quando o grau do polinômio é aumentado a partir de 3. Os índices da qualidade do ajuste inclusive indicam que a melhor aproximação é obtida com um polinômio do terceiro grau. Evidentemente, se outro trecho da curva tivesse sido escolhido. \\
\end{resposta}

\clearpage

\begin{pergunta}
\perguntac{}
\end{pergunta}
\begin{resposta}
I) Interpolação de Hermite: \\
A interpolação de Hermite utiliza $ n \text{ pontos } (x,y) \text{ da função e } n \textit{ pontos } (x, y') $ de sua derivada. Permite o uso de um polinômio de grau muito menor, $ \frac{n - 1}{2} $ em lugar de $ n - 1 $, o que, entre outras coisas, implica em menor oscilação do resultado \footnote{O chamado \textit{Fenômeno de Runge.}}. Os coeficientes são obtidos a partir da fórmula para os coeficientes de Lagrange. Evidentemente, seu emprego se limita aos casos em que os pontos da derivada são conhecidos. \\
O programa \textbf{\texttt{exercmat.c}}, em anexo, escrito em C, lê uma tabela em disco e interpola um ponto pelo método de Hermite. Basta digitar:
\listingsG
\begin{lstlisting}[language=Ada]
	exercmat 21 $ \textit{n} $
\end{lstlisting}
onde $ n $ é o tamanho da tabela (n x 3). Ele também calcula o número de operações em ponto flutuante necessário. \\
Um caso prático, trabalhado por \cite{TOBÓN 2011}, é a aproximação da função $ y = \ln(x) $ por meio de um polinômio; em todos os pontos se conhece a derivada $ y' = \frac{1}{x}. $ Neste caso, foram usadas tabela com 6, 10 e 20 entradas, para $ 1 \le x \le 5.5 $, resultando em polinômios de grau crescente. O ponto interpolado foi $ x = 3.1 $; o valor exato é $ y = 1.131402 $. Os resultados obtidos estão mostrados abaixo. O valor obtido pela interpolação pelos métodos de Lagrange e de Neville também são mostrados, para comparação. A interpolação de Lagrange pode ser obtida digitando-se:
\listingsG
\begin{lstlisting}[language=Ada]
	exercmat 19 $ \textit{n} $
\end{lstlisting}
e a interpolação de Neville é obtida digitando-se:
\listingsG
\begin{lstlisting}[language=Ada]
	exercmat 24 $ \textit{n} $
\end{lstlisting}
As técnicas de Lagrange e de Neville não consideram o valor da derivada. \\
\clearpage
\begin{minipage*}{\textwidth}
\centering
    \begin{tabular}{|c|c|c|c|c|}
		\hline
        \textbf{n} & \textbf{Hermite} & \textbf{Lagrange} & \textbf{Neville} & \textbf{custo} \footnote{Número de operações de ponto flutuante necessárias.} \\
		\hline
		$ 3 $ & $ 1.31482 $ & $ 1.138113 $ & $ 1.124153 $ & $ 81 $ \\
		$ 5 $ & $ 1.31399 $ & $ 1.130888 $ & $ 1.131802 $ & $ 215 $ \\
		$ 10 $ & $ 1.31400 $ & $ 1.131401 $ & $ 1.131402 $ & $ 830 $ \\
		\hline
    \end{tabular}
\end{minipage*}
O número ideal de entradas é 10, neste caso, 5 para $ y $ e 5 para $ y' $, que corresponde a um polinômio interpolador de grau 9. Mais pontos não melhoram muito a precisão e aumentam bastante o custo computacional. A técnica se mostrou superior às interpolações de Lagrange e de Neville para o mesmo número de pontos. \\
Uma grande desvantagem da técnica é que cada ponto a ser interpolado exige o recálculo de todos os coeficientes \cite{FREITAS 2010,TOBÓN 2011}. \\
\hlin
II) \textit{Spline} cúbico: \\
O problema anterior pode ser resolvido de forma alternativa por meio de \textit{spline} cúbico. A técnica consiste em não ajustar um mesmo polinômio a todos os pontos conhecidos, e sim ajustar polinômios de grau 3 diferentes a grupos de 4 pontos consecutivios. Condições extras são introduzidas de forma a evitar descontinuidades nas derivadas primeiras e segundas. Condições adicionais devem ser impostas às derivadas primeira e segunda nos pontos extremos: 
\begin{listae}[1]
	\item $ y''(x_1) = y''(x_1) = 0 $ (a chamda condição de \textbf{\textit{spline} natural}), ou
	\item $ y''(x_1) = y''(x_2) \text{ e } y''(x_{n-1}) = y''(x_n) $, ou
	\item $ y''(x_1) \text{ e } y''(x_n) $ são obtidos por extrapolação linear, ou
	\item $ y'(x_1) = \textrm{A} \text{ e } y'(x_{n-1}) = \textrm{B} $
\end{listae}
O programa \textbf{\texttt{exercmat.c}}, em anexo, escrito em C, lê uma tabela em disco e interpola um ponto por tal método, considerando as derivadas ou não. Basta digitar:
\listingsG
\begin{lstlisting}[language=Ada]
	exercmat 22 $ \textit{n} $
\end{lstlisting}
onde $ n $ é o tamanho da tabela. Ele também calcula o número de operações em ponto flutuante necessário. A condição de \textit{spline} natural é sempre imposta. \\
Verifica-se que a consideração da derivada melhora bastante a precisão e diminui o custo computacional. A exatidão, contudo, é inferior à obtida com um polinômio de mais alto grau. A técnica do \textit{spline}, além de ser mais simples, ainda permite o reaproveitamento dos coeficientes para interpolação de outros pontos \cite{KOKKOTAS 2015,KUCKIR 2014,ONEILL 2002,OUYED 2011,PRESS 1992 2}. \\
\\[\baselineskip]
\begin{minipage*}{\textwidth}
\centering
    \begin{tabular}{|c|c|c|c|}
		\hline
        \textbf{n} & \textbf{derivadas} & \textbf{resultado} & \textbf{custo} \footnote{Número de operações de ponto flutuante necessárias.} \\
		\hline
		$ 5 $ & Não & $ 1.119492 $ & $ 127 $ \\
		$ 10 $ & Não & $ 1.120845 $ & $ 317 $ \\
		$ 5 $ & Sim & $ 1.31414 $ & $ 20 $ \\
		$ 10 $ & Sim & $ 1.31404 $ & $ 20 $ \\
		\hline
    \end{tabular}
\end{minipage*}
\hlin
III) Extrapolação: \\
As técnicas de interpolação podem também, a princípio, ser usadas para extrapolação, contanto que o ponto extrapolado não esteja muito distante do intervalo onde os pontos são conhecidos. A técnica do \textit{spline} cúbico natural, devido às condições extras impostas aos pontos extremos, não se presta a esse uso. \\
O programa \textbf{\texttt{exercmat.c}}, em anexo, escrito em C, lê uma tabela em disco e extrapola um ponto por quatro métodos: o de Lagrange, o de Neville, o de Hermite e o \textit{spline} cúbico. Basta digitar:
\listingsG
\begin{lstlisting}[language=Ada]
	exercmat 23 $ \textit{n} $
\end{lstlisting}
onde $ n $ é o tamanho da tabela. Ele também calcula o número de operações em ponto flutuante necessário. Os resultados são mostrados abaixo: \\
\\[\baselineskip]
\begin{minipage*}{\textwidth}
\centering
    \begin{tabular}{|c|c|c|c|c|}
		\hline
        \textbf{n} & \textbf{valor exato} & \textbf{Lagrange} & \textbf{Hermite} & \textbf{Neville} \\
		\hline
		$ 5 $ & $ 1.629240 $ & $ 1.626772 $ & $ 1.629260 $ & $ 1.769480 $ \\
		$ 10 $ & $ 1.722767 $ & $ 1.722921 $ & $ 1.712949 $ & $ 1.713927 $ \\
		\hline
    \end{tabular}
\end{minipage*}
\\[\baselineskip]
A tabela confirma a tendência de a técnica de Hermite ser a mais precisa e mais cara, e a de Neville, a menos precisa e mais barata.
\end{resposta}

\clearpage

\begin{pergunta}
\perguntad{}
\end{pergunta}
\begin{resposta}
O programa \textbf{\texttt{exercmat.c}}, em anexo, escrito em C, lê uma tabela em disco e encontra o polinômio interpolador com o maior grau possível. Basta digitar:
\listingsG
\begin{lstlisting}[language=Ada]
	exercmat 18 $ \textit{n} $
\end{lstlisting}
onde $ n $ é o tamanho da tabela (n x 2). Ele também calcula o número de operações em ponto flutuante necessário para cada etapa. \\
Os coeficientes encontrados para o PIB foram: \\
$ a_9 = 5.900000 \text{, } a_8 = 24.808952 \text{, } a_7 = -60.370991 \text{, } a_6 = 49.870708 \text{, } a_5 = -19.498470 \text{,} $ \\
$ a_4 = 3.804901 \text{, } a_3 = -0.311178 \text{, } a_2 = -0.005871 \text{, } a_1 = 0.002509 \text{, } a_0 = -0.000111 $ \\
A expressão do polinômio interpolador é: \\
$ y = \sum_{i = 0}^9 a_i x^i $ \\
com $ x = ano - 1994 $.
Os coeficientes encontrados para o PIB per capita foram: \\
$ a_9 = 4.300000 \text{, } a_8 = 26.969584 \text{, } a_7 = -64.837807 \text{, } a_6 = 53.848827 \text{, } a_5 = -21.452248 \text{,} $ \\
$ a_4 = 4.385204 \text{, } a_3 = -0.417683 \text{, } a_2 = 0.005891 \text{, } a_1 = 0.001795 \text{, } a_0 = -0.000093 $. \\
\end{resposta}

\clearpage

%\end{}section

\section{Anexos}
Os seguintes arquivos constam do anexo (arquivo \textbf{\texttt{exercmat1.zip}}):
\begin{lista}
	\item arquivo fonte em C \textbf{\texttt{exercmat.c}}
	\item arquivos de dados:
	\begin{itemize}
		\item A\textit{n}: problema 1
		\item E\textit{n}: problema 2
		\item B\textit{n}: problemas 3 e 4
	\end{itemize}
\end{lista}

\noindent\makebox[\linewidth]{\rule{\paperwidth}{1pt}}

\clearpage

%\end{}section

\begin{thebibliography}{30}

\newbibsi{FASSHAUER 2006}{FASSHAUER 2006}{Greg FASSHAUER}{Numerical Linear Algebra/Computational Mathematics I}{Illinois Institute of Technology, 2006}{http://www.math.iit.edu/~fass/477577_Chapter_2.pdf}{25/03/2016}

\newbibit{FREITAS 2010}{FREITAS 2010}{Pedro Garcia FREITAS}{3.1.4 Aproximação de Funções — Interpolação — Interpolação de Hermite}{http://www.sawp.com.br/blog/?p=880}{04/04/2016}

\newbibit{KOKKOTAS 2015}{KOKKOTAS 2015}{Kostas KOKKOTAS}{Interpolation, Extrapolation ans Polynomial Approximation}{http://www.tat.physik.uni-tuebingen.de/~kokkotas/Teaching/Num_Methods_files/Comp_Phys3.pdf}{17/04/2016}

\newbibit{KUCKIR 2014}{KUCKIR 2014}{Ivan KUCKIR}{Interpolation with Cubic Splines}{http://blog.ivank.net/interpolation-with-cubic-splines.html}{05/04/2016}

\newbibit{ONEILL 2002}{ONEILL 2002}{Charles O’NEILL}{Cubic Spline Interpolation MAE 5093}{http://charles-oneill.com/projects/cubicspline.pdf}{04/04/2016}

\newbibit{OUYED 2011}{OUYED 2011}{Rachid OUYED e Woflgang DOBLER}{Interpolation, Extrapolation ans Polynomial Approximation}{Chap. 4, 2011, pp. 53 a 55}{http://pjl.ucalgary.ca/courses/physics381/computational-physics/Ouyed-Chapter-4-Interpolation-Extrapolation-Techniques.pdf}{17/04/2016}

\newbibsi{PRESS 1992 1}{PRESS 1992 1}{William H. PRESS, Saul A. TEUKOLSKY, William T. VETTERLING and Brian P. FLANNERY}{Numerical recipes in Fortran 77: The art of scientific computing Vol. 1}{Cambridge University Press, 2nd. Ed., 1992, ISBN 0-521-43064-X, Chap. 3. pp. 51 a 63}{http://www.fing.edu.uy/if/cursos/fiscomp/extras/numrec/book/f3.pdf}{06/04/2016}

\newbiboc{PRESS 1992 2}{PRESS 1992 2}{William H. PRESS, Saul A. TEUKOLSKY, William T. VETTERLING and Brian P. FLANNERY}{Chap. 2. pp. 99 a 122}

\newbibit{TOBÓN 2011}{TOBÓN 2011}{Luis E. TOBÓN}{Newton, Lagrange and Hermite Interpolation: Convergence and Runge phenomena}{http://people.duke.edu/~let12/pdf/courses/math225/LuisTobon_HW1_Interpolation.pdf}{04/04/2016}

\newbibbk{VETTERLI 2014}{VETTERLI 2014}{M. VETTERLI, J. KOVACEVIC e V. K. GOYAL}{Foundations of Signal Processing}{Cambridge University Press, March 2014, ISBN 110703860X [free version], pp. 59 a 60 e 146 a 147}{30/04/2016}

\end{thebibliography}

\noindent\makebox[\linewidth]{\rule{\paperwidth}{1pt}}

Programas testados com \textbf{Octave} 4.0.0, \textbf{Scilab} 5.5.2 e \textbf{MinGW} C 4.8.2: \\
\url{https://www.scilab.org} \\
\url{https://www.gnu.org/software/octave/} \\
\url{https://www.mingw.org} \\
Texto formatado com \textbf{pdflatex} em ambiente \textbf{MiKTeX} 2.9: \\
\url{http://miktex.org/download/} \\ \\
\end{document}
Imagens de teste obtidas em:
\url{http://eeweb.poly.edu/~yao/EL5123/SampleData.html}